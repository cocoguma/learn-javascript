(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{294:function(v,_,a){v.exports=a.p+"assets/img/img1.10150170.png"},306:function(v,_,a){"use strict";a.r(_);var t=a(14),s=Object(t.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"数据结构的分类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据结构的分类"}},[v._v("#")]),v._v(" 数据结构的分类")]),v._v(" "),_("p",[_("img",{attrs:{src:a(294),alt:"avatar"}})]),v._v(" "),_("ul",[_("li",[v._v("线形数据结构：数据元素按顺序或线形排列的数据结构，其中每一个元素都附加到其上一个和下一个相邻元素。\n"),_("ul",[_("li",[v._v("静态数据结构：具有固定的内存大小，访问更加容易。")]),v._v(" "),_("li",[v._v("动态数据结构：大小不固定，可以在运行期间随机更新，更加灵活节省空间。")])])]),v._v(" "),_("li",[v._v("非线性数据结构：数据元素不按顺序或线形放置，只能在一次运行中遍历所有元素。")])]),v._v(" "),_("h2",{attrs:{id:"线性数据结构简介"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#线性数据结构简介"}},[v._v("#")]),v._v(" 线性数据结构简介")]),v._v(" "),_("p",[v._v("元素在一维钟排列，也称为线性维度")]),v._v(" "),_("h3",{attrs:{id:"特点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#特点"}},[v._v("#")]),v._v(" 特点")]),v._v(" "),_("ul",[_("li",[v._v("顺序组织：每个元素都有一个唯一前驱和唯一后继（首位除外）。")]),v._v(" "),_("li",[v._v("顺序保留：保留元素被添加到数据结构的顺序。")]),v._v(" "),_("li",[v._v("固定或动态大小：可以固定或动态大小。")]),v._v(" "),_("li",[v._v("高效访问：访问线性数据结构十分高效")])]),v._v(" "),_("h3",{attrs:{id:"常见线性数据结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#常见线性数据结构"}},[v._v("#")]),v._v(" 常见线性数据结构")]),v._v(" "),_("ul",[_("li",[v._v("数组：存储在连续内存位置的元素的集合。")]),v._v(" "),_("li",[v._v("链表：节点的集合，每个节点包含一个元素和对下一个节点的引用。（数据+指针）")]),v._v(" "),_("li",[v._v("堆栈：后进先出LIFO的元素集合")]),v._v(" "),_("li",[v._v("队列：先进后出FIFO的元素集合")])]),v._v(" "),_("h3",{attrs:{id:"数组"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数组"}},[v._v("#")]),v._v(" 数组")]),v._v(" "),_("h4",{attrs:{id:"特点-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#特点-2"}},[v._v("#")]),v._v(" 特点")]),v._v(" "),_("ul",[_("li",[v._v("同质元素：数组中的元素必须相同类型")]),v._v(" "),_("li",[v._v("连续内存分配：数组中的元素在连续的内存位置")]),v._v(" "),_("li",[v._v("从零开始的索引")]),v._v(" "),_("li",[v._v("随机访问：数组提供对元素的恒定时间访问（时间复杂度O(1)）。无论数组大小如何，访问任何元素需要的时间是一样的。")])]),v._v(" "),_("h4",{attrs:{id:"操作"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#操作"}},[v._v("#")]),v._v(" 操作")]),v._v(" "),_("ul",[_("li",[v._v("访问元素：O(1)。")]),v._v(" "),_("li",[v._v("插入：末尾O(1)，其他O(n)。")]),v._v(" "),_("li",[v._v("删除：末尾O(1)，其他O(n)。")]),v._v(" "),_("li",[v._v("搜索：线性搜索O(n)，二分O(logn)。")])]),v._v(" "),_("h3",{attrs:{id:"链表"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#链表"}},[v._v("#")]),v._v(" 链表")]),v._v(" "),_("h4",{attrs:{id:"特点-3"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#特点-3"}},[v._v("#")]),v._v(" 特点")]),v._v(" "),_("ul",[_("li",[v._v("节点：每个元素都是一个节点，包含数据和指针。")]),v._v(" "),_("li",[v._v("头：链表中的第一个节点。")]),v._v(" "),_("li",[v._v("尾部：链表中的最后一个节点")])]),v._v(" "),_("h4",{attrs:{id:"链表类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#链表类型"}},[v._v("#")]),v._v(" 链表类型")]),v._v(" "),_("ul",[_("li",[v._v("单链表：常规单向链表。如1->2->NULL")]),v._v(" "),_("li",[v._v("双向链表：每个节点有两个指针，一个指向后一个，一个指向前一个，允许两个方向的遍历。")]),v._v(" "),_("li",[v._v("循环链表：第一个和最后一个节点连接，末尾没有NULL。")])]),v._v(" "),_("h4",{attrs:{id:"操作-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#操作-2"}},[v._v("#")]),v._v(" 操作")]),v._v(" "),_("ul",[_("li",[v._v("访问元素：O(n)。")]),v._v(" "),_("li",[v._v("搜索：O(n)。")]),v._v(" "),_("li",[v._v("插入：有插入位置时，O(1)。")]),v._v(" "),_("li",[v._v("删除：有删除的位置时，O(1)。")])]),v._v(" "),_("h3",{attrs:{id:"堆栈"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#堆栈"}},[v._v("#")]),v._v(" 堆栈")]),v._v(" "),_("h4",{attrs:{id:"类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#类型"}},[v._v("#")]),v._v(" 类型")]),v._v(" "),_("p",[v._v("固定大小：会发生堆栈溢出错误，为空删除时也会出现下溢错误。\n动态大小：堆栈满的时候会自动增加容量，为空时会减少大小，用链表实现，允许挑战栈的大小。")]),v._v(" "),_("h4",{attrs:{id:"操作-3"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#操作-3"}},[v._v("#")]),v._v(" 操作")]),v._v(" "),_("p",[v._v("push:推入一个元素。\npop:推出一个元素。\ntop:返回最后插入的元素。\nsize:返回堆栈的大小，即存在的元素总数。\nisEmpty:堆栈是否为空。")]),v._v(" "),_("h3",{attrs:{id:"队列"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#队列"}},[v._v("#")]),v._v(" 队列")]),v._v(" "),_("h4",{attrs:{id:"类型-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#类型-2"}},[v._v("#")]),v._v(" 类型")]),v._v(" "),_("ul",[_("li",[v._v("输入受限队列：只能从一端获取输入，可以从任意一段删除。")]),v._v(" "),_("li",[v._v("输出受限队列：两端都可以获取输入，只能从一端删除。")]),v._v(" "),_("li",[v._v("循环队列：最后一个位置连接回第一个位置。")]),v._v(" "),_("li",[v._v("双端队列：两端都可以插入删除。")]),v._v(" "),_("li",[v._v("优先级队列：根据分配给元素的优先级访问。")])]),v._v(" "),_("h4",{attrs:{id:"操作-4"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#操作-4"}},[v._v("#")]),v._v(" 操作")]),v._v(" "),_("ul",[_("li",[v._v("Enqueue():将一个元素添加到队尾。")]),v._v(" "),_("li",[v._v("Dequeue():从队列中移除元素。")]),v._v(" "),_("li",[v._v("Peek()或front():获取队列前端节点可用的数据元素，但不删除。")]),v._v(" "),_("li",[v._v("after():获取队列后端元素，但不删除。")]),v._v(" "),_("li",[v._v("isFull():是否已满。")]),v._v(" "),_("li",[v._v("isNull():是否为空。")])]),v._v(" "),_("h2",{attrs:{id:"非线性数据结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#非线性数据结构"}},[v._v("#")]),v._v(" 非线性数据结构")]),v._v(" "),_("p",[v._v("元素以一对多，多对一和多对多维度排列。")]),v._v(" "),_("h3",{attrs:{id:"二叉树"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二叉树"}},[v._v("#")]),v._v(" 二叉树")]),v._v(" "),_("p",[v._v("树是分层数据结构。二叉树是一种树形结构，每个节点最多有两个子节点，分别为左子节点和右子节点。主要用链表来实现。二叉树由指向树中最顶层节点的指针表示。如果树为空，则 root 的值为 NULL。\n二叉树包含三部分：数据、左节点指针、右节点指针。")]),v._v(" "),_("h3",{attrs:{id:"二叉搜索树"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二叉搜索树"}},[v._v("#")]),v._v(" 二叉搜索树")]),v._v(" "),_("h5",{attrs:{id:"是具有以下附属属性的二叉树"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#是具有以下附属属性的二叉树"}},[v._v("#")]),v._v(" 是具有以下附属属性的二叉树：")]),v._v(" "),_("ul",[_("li",[v._v("根节点的左侧部分的key比根节点小")]),v._v(" "),_("li",[v._v("根节点的右侧部分的key比根节点大")]),v._v(" "),_("li",[v._v("不存在重复的key")])]),v._v(" "),_("h3",{attrs:{id:"堆"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#堆"}},[v._v("#")]),v._v(" 堆")]),v._v(" "),_("p",[v._v("堆是一种基于树的特殊数据结构，其中树是完全二叉树。一般有两种类型：")]),v._v(" "),_("ul",[_("li",[v._v("最大堆：根节点的key必须比左右子节点都大，此规则递归到最后一层。")]),v._v(" "),_("li",[v._v("最小堆：根节点的key必须比左右子节点都小，此规则递归到最后一层。")])])])}),[],!1,null,null,null);_.default=s.exports}}]);